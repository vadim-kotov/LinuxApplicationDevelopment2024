/*
Программа генерирует идеальный лабиринт.
То есть лабиринт без петель и недостижимых комнат.

Далее 'вершина' - комната, 'ребро' - стена

Используется алгоритм Крускала для построения остовного дерева.

Алгоритм всей программы:
	1. Инициализация закрытого лабиринта со всеми возможными стенами
	2. Инициализация массива всех возможных стен
	3. Перемешивание массива стен
	4. Работа алгоритма Крускала
		а) Инициализация массива родительских вершин parent:
			родителем каждой вершины помечается сама вершина
		б) Для каждой стены:
			i. вычисление корневых вершин компонент связности,
				к которым принадлежат комнаты, резделённые стеной
			ii. если корневые вершины разные, то 
				1) вершины объединяются 
				в одну компоненту связности посредством назначения 
				в качестве родителя второй вершины корня первой вершины.
				2) стена 'проламывается'
	5. Печать лабиринта
*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void init_parent(int *parent)
{
	for (int i = 0; i < 36; i++)
	{
		parent[i] = i;
	}
}

// Поиск корневой вершины компоненты связности.
//
// При этом происходит 'сжатие пути' до корня с целью оптимизации.
// После нахождения корня, у каждой вершины на пути к нему 
// родителем напрямую становится этот найденный корень
int find(int *parent, int x)
{
	if (parent[x] != x)
	{
		parent[x] = find(parent, parent[x]);
	}

	return parent[x];
}

// Проверка принадлежности комнат, разделённых стеной
// к разным компонентам связности их объединение
// Сравниваются корневые вершины компонент.
int union_sets(int *parent, int x, int y)
{
	int rootX = find(parent, x);
	int rootY = find(parent, y);

	if (rootX != rootY)
	{
		parent[rootY] = rootX;
		return 1;
	}

	return 0;
}

// x, y - координаты символов стены
// a, b - номера комнат, разделённых стеной
struct Wall
{
	int x, y;
	int a, b;
};

int main() {
	char maze[13][13];
	int parent[36];
	struct Wall walls[60];
	int k;
	int i, j;
	struct Wall tmp_wall;

	srand(time(NULL));

	//Закрытый лабиринт
	for (i = 0; i < 13; i++)
	{
		for (j = 0; j < 13; j++)
		{
			maze[i][j] = '#';
		}
	}

	for (i = 0; i < 6; i++)
	{
		for (j = 0; j < 6; j++)
		{
			maze[2*i + 1][2*j + 1] = '.';
		}
	}

	// Инициализация массива стен
	k = 0;
	// Вертикальные стены
	for (i = 0; i < 6; i++)
	{
		for (j = 0; j < 5; j++)
		{
			walls[k].x = 2*i + 1;
			walls[k].y = 2*j + 2;
			walls[k].a = i*6 + j;
			walls[k].b = i*6 + j + 1;
			k++;
		}
	}

	// Горизонтальные стены
	for (i = 0; i < 5; i++)
	{
		for (j = 0; j < 6; j++)
		{
			walls[k].x = 2*i + 2;
			walls[k].y = 2*j + 1;
			walls[k].a = i*6 + j;
			walls[k].b = (i+1)*6 + j;
			k++;
		}
	}

	// Перемешивание стен в массиве
	for (i = 59; i > 0; i--)
	{
		int j = rand() % (i + 1);
		tmp_wall = walls[i];
		walls[i] = walls[j];
		walls[j] = tmp_wall;
	}

	// Работа алгоритма Крускала
	init_parent(parent);
	for (i = 0; i < 60; i++)
	{
		int a = walls[i].a;
		int b = walls[i].b;
		// Если стена соединяет комнаты из разных компонент
		// связности, то стена 'проламывается'
		if (union_sets(parent, a, b))
		{
			maze[walls[i].x][walls[i].y] = '.';
		}
	}

	// Вывод на экран
	for (i = 0; i < 13; i++)
	{
		for (j = 0; j < 13; j++)
		{
			putchar(maze[i][j]);
		}
		putchar('\n');
	}

	return 0;
}
